#!/usr/bin/env bun
/**
 * Route generator script
 *
 * Scans route files and generates src/routes/index.ts
 *
 * Usage:
 *   bun scripts/generate-routes.ts          # Check only (exits 1 if out of date)
 *   bun scripts/generate-routes.ts --fix    # Generate and write file
 */

import { readdir, readFile, writeFile } from 'node:fs/promises'
import { join, relative } from 'node:path'

const FIX_MODE = process.argv.includes('--fix')

// ANSI colors
const c = {
	reset: '\x1b[0m',
	bold: '\x1b[1m',
	dim: '\x1b[2m',
	red: '\x1b[31m',
	green: '\x1b[32m',
	cyan: '\x1b[36m',
} as const

const ROUTES_DIR = join(import.meta.dirname, '../src/routes')
const OUTPUT_FILE = join(import.meta.dirname, '../src/routes/index.ts')
const HTTP_METHODS = ['get', 'post', 'put', 'delete', 'patch'] as const

interface RouteInfo {
	filePath: string
	importName: string
	routePath: string
}

async function findRouteFiles(dir: string, basePath = ''): Promise<RouteInfo[]> {
	const routes: RouteInfo[] = []
	const entries = await readdir(dir, { withFileTypes: true })

	for (const entry of entries) {
		const fullPath = join(dir, entry.name)
		const relativePath = join(basePath, entry.name)

		if (entry.isDirectory()) {
			routes.push(...(await findRouteFiles(fullPath, relativePath)))
		} else if (entry.name.endsWith('.ts') && !entry.name.endsWith('.test.ts')) {
			const methodName = entry.name.replace('.ts', '')

			if (HTTP_METHODS.includes(methodName as (typeof HTTP_METHODS)[number])) {
				const dirPath = basePath
				const routePath = convertToRoutePath(dirPath)
				const importName = generateImportName(dirPath, methodName)

				routes.push({
					filePath: relativePath.replace(/\\/g, '/').replace('.ts', ''),
					importName,
					routePath,
				})
			}
		}
	}

	return routes
}

function convertToRoutePath(filePath: string): string {
	const segments = filePath.split(/[/\\]/).filter(Boolean)
	const converted = segments.map((seg) => {
		if (seg.startsWith('[') && seg.endsWith(']')) {
			return `:${seg.slice(1, -1)}`
		}
		return seg
	})

	return `/${converted.join('/')}`
}

const capitalize = (s: string) => s.charAt(0).toUpperCase() + s.slice(1)

function printTree(items: RouteInfo[], color: string) {
	for (const [i, item] of items.entries()) {
		const isLast = i === items.length - 1
		const prefix = isLast ? 'â””â”€' : 'â”œâ”€'
		const num = String(i + 1).padStart(2, '0')
		console.log(
			`${c.dim}   ${prefix} ${c.reset}${c.dim}[${num}]${c.reset} ${color}${item.routePath}${c.reset}`,
		)
	}
}

function generateImportName(dirPath: string, method: string): string {
	const segments = dirPath.split(/[/\\]/).filter(Boolean)
	const parts = segments.map((seg) =>
		seg.startsWith('[') && seg.endsWith(']') ? capitalize(seg.slice(1, -1)) : capitalize(seg),
	)
	parts.push(capitalize(method))

	const result = parts.join('')
	return result.charAt(0).toLowerCase() + result.slice(1)
}

function generateIndexFile(routes: RouteInfo[]): string {
	const imports = routes.map((r) => `import ${r.importName} from './${r.filePath}'`).join('\n')

	const routeRegistrations = routes
		.map((r) => `app.route('${r.routePath}', ${r.importName})`)
		.join('\n')

	return `// Auto-generated by scripts/generate-routes.ts
// Do not edit manually

import { OpenAPIHono } from '@hono/zod-openapi'

${imports}

const app = new OpenAPIHono<{ Bindings: Cloudflare.Env }>()

${routeRegistrations}

export default app
`
}

async function main() {
	console.log(`\n${c.bold}${c.cyan}ğŸ”§ Route Generator${c.reset}\n`)

	const routes = await findRouteFiles(ROUTES_DIR)
	const sortedRoutes = [...routes].sort((a, b) => a.filePath.localeCompare(b.filePath))

	console.log(
		`${c.green}${c.bold}Registered routes${c.reset} ${c.dim}(${sortedRoutes.length} endpoints)${c.reset}`,
	)
	printTree(sortedRoutes, c.cyan)

	const content = generateIndexFile(sortedRoutes)
	const outputRelative = relative(process.cwd(), OUTPUT_FILE)

	// Read existing file
	let existing = ''
	try {
		existing = await readFile(OUTPUT_FILE, 'utf-8')
	} catch {
		// File doesn't exist
	}

	const isUpToDate = existing === content

	console.log()
	console.log(`${c.dim}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${c.reset}`)

	if (isUpToDate) {
		console.log(`${c.green}${c.bold}âœ… ${outputRelative} is up to date${c.reset}`)
		console.log(`${c.dim}   ${sortedRoutes.length} routes registered${c.reset}\n`)
		return
	}

	if (FIX_MODE) {
		await writeFile(OUTPUT_FILE, content, 'utf-8')
		console.log(`${c.green}${c.bold}âœ… Generated ${outputRelative}${c.reset}`)
		console.log(`${c.dim}   ${sortedRoutes.length} routes registered${c.reset}\n`)
	} else {
		console.log(`${c.red}${c.bold}âŒ ${outputRelative} is out of date${c.reset}`)
		console.log(`${c.dim}   Run with --fix to regenerate${c.reset}\n`)
		process.exit(1)
	}
}

main().catch(console.error)
