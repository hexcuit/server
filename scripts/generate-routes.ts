#!/usr/bin/env bun
/**
 * Route generator script
 *
 * Scans route files and generates src/routes/index.ts
 *
 * Usage:
 *   bun scripts/generate-routes.ts
 */

import { readdir, writeFile } from 'node:fs/promises'
import { join, relative } from 'node:path'

// ANSI colors
const c = {
	reset: '\x1b[0m',
	bold: '\x1b[1m',
	dim: '\x1b[2m',
	green: '\x1b[32m',
	cyan: '\x1b[36m',
} as const

const ROUTES_DIR = join(import.meta.dirname, '../src/routes')
const OUTPUT_FILE = join(import.meta.dirname, '../src/routes/index.ts')
const HTTP_METHODS = ['get', 'post', 'put', 'delete', 'patch'] as const

interface RouteInfo {
	filePath: string
	importName: string
	routePath: string
}

async function findRouteFiles(dir: string, basePath = ''): Promise<RouteInfo[]> {
	const routes: RouteInfo[] = []
	const entries = await readdir(dir, { withFileTypes: true })

	for (const entry of entries) {
		const fullPath = join(dir, entry.name)
		const relativePath = join(basePath, entry.name)

		if (entry.isDirectory()) {
			routes.push(...(await findRouteFiles(fullPath, relativePath)))
		} else if (entry.name.endsWith('.ts') && !entry.name.endsWith('.test.ts')) {
			const methodName = entry.name.replace('.ts', '')

			if (HTTP_METHODS.includes(methodName as (typeof HTTP_METHODS)[number])) {
				const dirPath = basePath
				const routePath = convertToRoutePath(dirPath)
				const importName = generateImportName(dirPath, methodName)

				routes.push({
					filePath: relativePath.replace(/\\/g, '/').replace('.ts', ''),
					importName,
					routePath,
				})
			}
		}
	}

	return routes
}

function convertToRoutePath(filePath: string): string {
	const segments = filePath.split(/[/\\]/).filter(Boolean)
	const converted = segments.map((seg) => {
		if (seg.startsWith('[') && seg.endsWith(']')) {
			return `:${seg.slice(1, -1)}`
		}
		return seg
	})

	return `/${converted.join('/')}`
}

function generateImportName(dirPath: string, method: string): string {
	const segments = dirPath.split(/[/\\]/).filter(Boolean)
	const parts: string[] = []

	for (const seg of segments) {
		if (seg.startsWith('[') && seg.endsWith(']')) {
			const param = seg.slice(1, -1)
			parts.push(param.charAt(0).toUpperCase() + param.slice(1))
		} else {
			parts.push(seg.charAt(0).toUpperCase() + seg.slice(1))
		}
	}

	parts.push(method.charAt(0).toUpperCase() + method.slice(1))

	const result = parts.join('')
	return result.charAt(0).toLowerCase() + result.slice(1)
}

function generateIndexFile(routes: RouteInfo[]): string {
	const sortedRoutes = [...routes].sort((a, b) => a.filePath.localeCompare(b.filePath))

	const imports = sortedRoutes
		.map((r) => `import ${r.importName} from './${r.filePath}'`)
		.join('\n')

	const routeRegistrations = sortedRoutes
		.map((r) => `app.route('${r.routePath}', ${r.importName})`)
		.join('\n')

	return `// Auto-generated by scripts/generate-routes.ts
// Do not edit manually

import { OpenAPIHono } from '@hono/zod-openapi'

${imports}

const app = new OpenAPIHono<{ Bindings: Cloudflare.Env }>()

${routeRegistrations}

export default app
`
}

async function main() {
	console.log(`\n${c.bold}${c.cyan}ðŸ”§ Route Generator${c.reset}\n`)

	const routes = await findRouteFiles(ROUTES_DIR)
	const sortedRoutes = [...routes].sort((a, b) => a.filePath.localeCompare(b.filePath))

	console.log(
		`${c.green}${c.bold}Registered routes${c.reset} ${c.dim}(${sortedRoutes.length} endpoints)${c.reset}`,
	)

	for (const [i, route] of sortedRoutes.entries()) {
		const isLast = i === sortedRoutes.length - 1
		const prefix = isLast ? 'â””â”€' : 'â”œâ”€'
		const num = String(i + 1).padStart(2, '0')
		console.log(
			`${c.dim}   ${prefix} ${c.reset}${c.dim}[${num}]${c.reset} ${c.cyan}${route.routePath}${c.reset}`,
		)
	}

	const content = generateIndexFile(routes)
	await writeFile(OUTPUT_FILE, content, 'utf-8')

	const outputRelative = relative(process.cwd(), OUTPUT_FILE)

	console.log()
	console.log(`${c.dim}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${c.reset}`)
	console.log(`${c.green}${c.bold}âœ… Generated ${outputRelative}${c.reset}`)
	console.log(`${c.dim}   ${sortedRoutes.length} routes registered${c.reset}\n`)
}

main().catch(console.error)
